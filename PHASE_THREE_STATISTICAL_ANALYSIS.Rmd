---
title: "PHASE_THREE_STATISTICAL_ANALYSIS"
author: "Chris Low"
date: "01/09/2021"
output: html_document
---

```{r setup, include=FALSE}

library(tidyverse) # data wrangling and visualization
library(ggplot2) # data visualization
library(GGally) # visulizing scatterplots
library(performance) # check model outputs
library(lme4) # analysis for logistic regressions and mixed-effects modelling
library(corrplot) # creating a correlation matrix
library(sjPlot) # to visualizing mixed-effects models
library(effects) # to visualizing mixed-effects models
library(report) # mainly for an "report" function
library(emmeans) # post-hoc analysis
library(knitr) # beautifying tables
library(MASS) # model selection using drop terms
library(pscl) # zero-inflation regression models
library(MuMIn) # model comparison

```

## Loading in final dataset in r

```{r load data, echo=TRUE}

# Just save priority EDGE lineage list and PD_mammal_merged list as essential for analysis: mammals_pd_merged, EDGE_priority_lineages, ePD_priority_lineages (final datasets so far!!!)
load("C:/Users/Student/Zoological Society of London/EDGEofExistence - Chris Low - EDGE lineages/Project II/Data and analysis/EDGE_families_and_scores/EDGE_LINEAGES_FOR_ANALYSIS.RData")

# load dataout datasets with both Upham and Gumbs datasets
load("C:/Users/Student/Zoological Society of London/EDGEofExistence - Chris Low - EDGE lineages/Project II/Data and analysis/Mammal phylogenies/ePD_scores_ALL.RData")

```

## Testing the difference between

You can also embed plots, for example:

```{r testing phylogeny datasets, echo=FALSE}

# Spearmans's rank correaltion between imputted an non-imputed datasets
cor.test(ex_PD_full$Median.exPD, ex_PD_full$Median.ePD.UPHAM, method = "spearman")

# subset and log variables
ePD_spp_rich_df <- mammals_pd_merged[,c(3,14,39)]
ePD_spp_rich_df$log_richness <- log(ePD_spp_rich_df$richness)
ePD_spp_rich_df$log_ePD <- log(ePD_spp_rich_df$Median.exPD)


# Spearman's rank correlation between species richness and ePD
cor.test(ePD_spp_rich_df$richness, ePD_spp_rich_df$Median.exPD, method = "spearman")

cor.test(ePD_spp_rich_df$richness, ePD_spp_rich_df$median_EDGE, method = "spearman")


```
## Question (i) How do intrinsic and extrinsic threats predict ED?

```{r intrinsic and extrinsic threats, echo=TRUE}

# 
ePD_response_df <- mammals_pd_merged[,c(1,3:4,9,14,26:39,48:49)]

# visulising distributions of data
# distribution of response variable is poission
par(mfrow=c(3:4))
for(i in 3:27) {
    hist(ePD_response_df[,i], main=names(ePD_response_df)[i])
}

# log transforming variables
ePD_response_df$ePD_log <- log(ePD_response_df$Median.exPD + 1)
ePD_response_df$ED_log <- log(ePD_response_df$median_ED + 1)
ePD_response_df$bodysize_log <- log(ePD_response_df$bodysize_mean + 1)
ePD_response_df$gensize_log <- log(ePD_response_df$Gen_length_days + 1)

# Calculate number of occurences which are greater than 0 to sum threat data
ePD_response_df$threat_sum <- apply(ePD_response_df[,c("prop_1_1","prop_2_2","prop_2_3","prop_5_1","prop_5_3","prop_8_1")], 1, function(x) length(which(x > 0)))


# check colinearity of data
# creating a correlation matrix
correlations <- cor(ePD_response_df[,2:22])
corrplot(correlations, method="circle")

ePD_response_df <- ePD_response_df[complete.cases(ePD_response_df),]

# run a glm- MAXIMAL MODEL
ED_glm_full <- glm(log(median_ED + 1) ~ log(bodysize_mean + 1) + log(Gen_length_days +1) + prop_1_1 + prop_2_2 + prop_2_3 + prop_5_1 + prop_5_3 + prop_8_1 + threat_sum, 
              family = gaussian,
              na.action = "na.fail",
              data = ePD_response_df) 

summary(ED_glm)

# find out explanatory power
with(summary(ED_glm), 1 - deviance/null.deviance)

# check model performance - assumptions not violated - no they are not xx
check_model(ED_glm)

model_selction <- step(ED_glm, direction = "backward")

# update the new model
ED_glm_new <- glm(formula = log(median_ED + 1) ~ prop_2_3 + prop_5_3 + prop_8_1 + 
    threat_sum, family = gaussian, data = ePD_response_df, na.action = "na.fail")

# find out explanatory power
with(summary(ED_glm_new), 1 - deviance/null.deviance)

# Using anova to comapre model fits - keep full model as it has the highest explanatory power
anova(ED_glm_new, ED_glm_full, test = "F")

# create null model
ED_null <- glm(log(median_ED + 1) ~ 1, data = ePD_response_df)

anova(ED_glm_full, ED_null, test = "F")

# Lastly- check model assumptions 
check_model(ED_glm_full)

# Check if intrinsic and extrintic threats respond to EDGE score

# run a glm with EDGE score as the response variable- MAXIMAL MODEL
EDGE_glm_full <- glm(log(median_EDGE + 1) ~ log(bodysize_mean + 1) + log(Gen_length_days +1) + prop_1_1 + prop_2_2 + prop_2_3 + prop_5_1 + prop_5_3 + prop_8_1 + threat_sum, 
              family = gaussian,
              na.action = "na.fail",
              data = ePD_response_df) 

# get model summary
summary(EDGE_glm_full)

# find out explanatory power
with(summary(EDGE_glm_full), 1 - deviance/null.deviance)

# check model performance - assumptions not violated - no they are not xx
check_model(EDGE_glm_full)

# backwards stepwise model selection
model_selction_EDGE <- step(ED_glm, direction = "backward")

EDGE_glm_update <- glm(log(median_EDGE + 1) ~ prop_2_3 + prop_5_3 + prop_8_1 + threat_sum, 
                       family = gaussian,
                       na.action = "na.fail",
                       data = ePD_response_df) 

# get model summary
summary(EDGE_glm_update)

# find out explanatory power
with(summary(EDGE_glm_update), 1 - deviance/null.deviance)

# Compare full and updated model- USE FULL MODEL
anova(EDGE_glm_full, EDGE_glm_update, test = "F")

# Create null model
EDGE_glm_null <- glm(log(median_EDGE + 1) ~ 1, 
                       family = gaussian,
                       na.action = "na.fail",
                       data = ePD_response_df) 

# compare full model to the null
anova(EDGE_glm_full, EDGE_glm_null, test = "F")

# now try glmm to see if it can explain any additional variation
# building a mixed-effects linear logistic regression
m <- lmer(log(median_ED +1) ~ log(bodysize_mean +1) + log(Gen_length_days +1)  + threat_sum + prop_2_2 + prop_2_3 + prop_5_1 + prop_5_3 + prop_8_1 + (1 | Order), data = ePD_response_df)

summary(m)

confint(m)

ranef(m)

print(anova(m))

### Summary- DON'T use LMM modelling 


```

## Question (ii) Does the response of population decline interact with the proportion of extrinsic (anthropogenic) threats?


```{r explore data, echo=TRUE}

# subset data to only contain population probabilities
threat_interacts_df <- mammals_pd_merged[,c(1:3,9,14,20:37,40,49)]

names(threat_interacts_df)

head(threat_interacts_df)

summary(threat_interacts_df)

# Change lineage priority as threat
threat_interacts_df$priority_type <- as.factor(threat_interacts_df$EDGE_priority)

# convert prioirty values to 1's and 0's
threat_interacts_df$EDGE_priority[threat_interacts_df$EDGE_priority == "No"] <- 0
threat_interacts_df$EDGE_priority[threat_interacts_df$EDGE_priority == "Yes"] <- 1

# Calculate number of occurences which are greater than 0 to sum threat data
threat_interacts_df$threat_sum <- apply(ePD_response_df[,c("prop_1_1","prop_2_2","prop_2_3","prop_5_1","prop_5_3","prop_8_1")], 1, function(x) length(which(x > 0)))

# change to binary operator
threat_interacts_df$EDGE_priority <- as.numeric(threat_interacts_df$EDGE_priority)


# visulising distibutions of data
par(mfrow=c(3,4))
for(i in 3:11) {
    hist(priority_lineages_df[,i], main=names(priority_lineages_df)[i])
}

# Viewing the distribution of variables
GGally::ggpairs(priority_lineages_df[, c("assessed_threat_prop", "Prop_dec", "Prop_inc", "Prop_stab")])

# boxplot
boxplot(priority_lineages_df$Prop_dec)

# creating a correlation matrix
correlations <- cor(priority_lineages_df[,3:11])
corrplot(correlations, method="circle")

# Replace all NA values with 0
priority_lineages_df[is.na(priority_lineages_df)] <- 0

# double check strucutre of dataset
str(priority_lineages_df)

# check for generalized inflation factors - look at colinearity  
corvif(EDGE_priority_lineages)

# glm in which EDGE or ED scores is a responds to proportion of threatened species interacts with threats
# perform a glm fit
threats_glm <- glm(prop_uplisted ~ assessed_threat_prop: prop_1_1 + prop_2_2 + prop_2_3 + prop_5_1 + prop_5_3 + prop_8_1 + threat_sum, family = poisson("log"), data = threat_interacts_df)

summary(threats_glm)

priority_lineage_glm <- glm.nb(EDGE_priority ~ Prop_dec + Prop_inc + Prop_stab + prop_uplisted + prop_downlisted + prop_stable, data = priority_lineages_df)

# check for model performance
performance::check_model(priority_lineage_glm)

# Get summary of results
summary(priority_lineage_glm)

# find out explanatory power
with(summary(priority_lineage_glm), 1 - deviance/null.deviance)

# try a zero-inflated binomial regression
m1 <- zeroinfl(EDGE_priority ~ Prop_dec + Prop_inc + Prop_stab + prop_uplisted + prop_downlisted + prop_stable | priority_type,
  data = priority_lineages_df, dist = "poisson")

summary(m1)

m1 <- zeroinfl(EDGE_priority ~ Trend_dec + Trend_inc + Trend_stab + no_stable + no_uplisted + no_downlisted | priority_type,
  data = mammals_pd_merged, dist = "negbin")


# building a mixed-effects linear logistic regression
GLMM_prioirty_lineages <- glmer(EDGE_priority ~ Prop_dec + Prop_inc + Prop_stab + prop_downlisted + prop_uplisted + prop_stable + (1 | Order), 
                                data = priority_lineages_df,
                                family = binomial,
                                control = glmerControl(optimizer = "bobyqa"))



GLMM_priority_lineages <- glme(EDGE_priority ~ Prop_dec + Prop_inc + Prop_stab + prop_downlisted + prop_uplisted + prop_stable + (1 | Family/Order), data = priority_lineages_df, 
                 control = glmerControl(optimizer = "bobyqa"))

check_model(m_ri)

summary(m_ri)

tab_model(m_ri, show.aic = T)

```

## Question (iii) Is the response of population status/family associated with the concentration of anthropogenic threats for priority lineages

```{r threat analaysis, echo=TRUE}

#subset threat data
threat_analysis_df <- mammals_pd_merged[,c(1:3,9,21,29, 34:45)]

# creating a correlation matrix - no correlations between variables. Can therefore dismiss the assumption of non-independence
correlations <- cor(threat_analysis_df[,3:18])
corrplot(correlations, method="circle")

```
